#!/bin/bash

MODULUS_COREOS_RELEASE_BOARD=${MODULUS_COREOS_RELEASE_BOARD:-$COREOS_RELEASE_BOARD}
MODULUS_COREOS_RELEASE_VERSION=${MODULUS_COREOS_RELEASE_VERSION:-$COREOS_RELEASE_VERSION}
MODULUS_DOCKER=${MODULUS_DOCKER:-false}
MODULUS_DIR=${MODULUS_DIR:-/opt/modulus}
MODULUS_FORCE=${MODULUS_FORCE:-false}
MODULUS_GROUP=${MODULUS_GROUP:-$GROUP}
MODULUS_S3_BUCKET=${MODULUS_S3_BUCKET}
MODULUS_UPLOAD=${MODULUS_UPLOAD:-false}

check_for_update() {
    while read -r e ; do export $e ;done < <(update_engine_client -status 2>/dev/null)
    [ "$CURRENT_OP" == "UPDATE_STATUS_UPDATED_NEED_REBOOT" ] && MODULUS_COREOS_RELEASE_VERSION=$NEW_VERSION
}

while getopts ":b:B:cd:Dfg:r:u" o; do
    case $o in
        b)
            MODULUS_COREOS_RELEASE_BOARD=$OPTARG;;
        B)
            MODULUS_S3_BUCKET=$OPTARG;;
        c)
            check_for_update;;
        d)
            MODULUS_DIR=$OPTARG;;
        D)
            MODULUS_DOCKER=true;;
        f)
            MODULUS_FORCE=true;;
        g)
            MODULUS_GROUP=$OPTARG
            if [ "$MODULUS_GROUP" != alpha ] && [ "$MODULUS_GROUP" != beta ] && [ "$MODULUS_GROUP" != stable ]; then
                echo "Usage: $(basename "$0") [-g <alpha|beta|stable>]" 1>&2; exit 1;
            fi
            ;;
        r)
            MODULUS_COREOS_RELEASE_VERSION=$OPTARG;;
        u)
            MODULUS_UPLOAD=true;;
        \?)
            echo "Invalid option: -$OPTARG" >&2
            exit 1
            ;;
        :)
            echo "Option -$OPTARG requires an argument." >&2
            exit 1
            ;;
    esac
done
shift $((OPTIND-1))


check_status() {
    local DRIVER_NAME=$1
    local DRIVER_VERSION=$2
    local KERNEL_VERSION=$(uname -r)
    if [ -d /opt/"$DRIVER_NAME"/"$DRIVER_VERSION"/lib/modules/"$KERNEL_VERSION" ]; then
        echo "$DRIVER_NAME $DRIVER_VERSION is up to date"
        return 0;
    fi
    echo "$DRIVER_NAME $DRIVER_VERSION is out of date" 1>&2
    return 1;
}

compile() {
    local DRIVER_NAME=$1
    local DRIVER_VERSION=$2
    [ "$MODULUS_FORCE" = false ] && check_status "$DRIVER_NAME" "$DRIVER_VERSION" && exit 0

    local CONTAINER_URL=http://$MODULUS_GROUP.release.core-os.net/$MODULUS_COREOS_RELEASE_BOARD/$MODULUS_COREOS_RELEASE_VERSION/coreos_developer_container.bin.bz2

    echo "Compiling kernel modules for $DRIVER_NAME $DRIVER_VERSION, Container Linux $MODULUS_GROUP $MODULUS_COREOS_RELEASE_BOARD $MODULUS_COREOS_RELEASE_VERSION"
    mkdir -p "$MODULUS_DIR"/archive/"$DRIVER_NAME"/"$DRIVER_VERSION"
    pushd "$MODULUS_DIR"/archive/"$DRIVER_NAME"/"$DRIVER_VERSION" > /dev/null
    gpg2 --recv-keys 48F9B96A2E16137F
    curl -L "$CONTAINER_URL" | tee >(bzip2 -d > coreos_developer_container.bin) | gpg2 --verify <(curl -Ls "$CONTAINER_URL.sig") -

    if [ "$MODULUS_DOCKER" = false ] ; then
        sudo systemd-nspawn \
            --bind-ro="$MODULUS_DIR":/opt/modulus \
            --bind="$PWD":/out \
            --setenv=DRIVER_VERSION="$DRIVER_VERSION" \
            --setenv=MODULUS_COREOS_RELEASE_VERSION="$MODULUS_COREOS_RELEASE_VERSION" \
            --setenv=MODULUS_GROUP="$MODULUS_GROUP" \
            --image=coreos_developer_container.bin \
            --register=no \
            /opt/modulus/"$DRIVER_NAME"/compile
    else
        bin_to_tar coreos_developer_container.bin coreos_developer_container
        docker run --rm \
            -v "$MODULUS_DIR":/opt/modulus:ro \
            -v "$PWD":/out \
            -e DRIVER_VERSION="$DRIVER_VERSION" \
            -e MODULUS_COREOS_RELEASE_VERSION="$MODULUS_COREOS_RELEASE_VERSION" \
            -e MODULUS_GROUP="$MODULUS_GROUP" \
            coreos_developer_container /opt/modulus/"$DRIVER_NAME"/compile
    fi

    [ "$MODULUS_UPLOAD" = false ] && exit 0
    upload "$DRIVER_NAME" "$DRIVER_VERSION"
}

bin_to_tar() {
    if [ -z "$1" ] || [ -z "$2" ] ; then
        echo "err: no binary or no tar specified"
        return 1
    fi

    local IN=$1
    local OUT=$2
    local START=$(gdisk -l "$IN" | grep ROOT | awk '{print $2}')
    local END=$(gdisk -l "$IN" | grep ROOT | awk '{print $3}')
    dd if="$IN" of="$IN" bs=512 skip="$START" conv=notrunc
    truncate -s $(((END-4096+1)*512)) "$IN"
    local DIR=$(mktemp -d)
    mount "$IN" "$DIR"
    rm "$IN"
    pushd "$DIR" > /dev/null
    tar -c . | docker import - "$OUT"
    popd > /dev/null
    umount "$DIR"
}

install() {
    local DRIVER_NAME=$1
    local DRIVER_VERSION=$2
    if [ "$MODULUS_FORCE" = true ] ; then
        rm -rf /opt/"$DRIVER_NAME"
    elif [ -e /opt/"$DRIVER_NAME" ] ; then
        echo "/opt/$DRIVER_NAME exists; use -f to force install"
        exit 1
    fi

    ln -s "$MODULUS_DIR"/archive/"$DRIVER_NAME" /opt/"$DRIVER_NAME"
    mkdir -p /etc/ld.so.conf.d
    echo /opt/"$DRIVER_NAME"/"$DRIVER_VERSION"/lib > /etc/ld.so.conf.d/"$DRIVER_NAME"-"$DRIVER_VERSION".conf
    ldconfig 2> /dev/null
}

upload() {
    local DRIVER_NAME=$1
    local DRIVER_VERSION=$2
    pushd "$MODULUS_DIR"/archive/"$DRIVER_NAME"/"$DRIVER_VERSION" > /dev/null
    tar -cvzf "$MODULUS_COREOS_RELEASE_VERSION"-"$MODULUS_GROUP"-"$DRIVER_NAME"-"$DRIVER_VERSION".tar.gz --exclude=./*.tar.gz --exclude=./coreos_developer_container* .
    . /home/core/awsenv
    for t in ./*.tar.gz; do \
        rkt run \
            --net=host \
            --dns=host \
            --trust-keys-from-https quay.io/coreos/awscli:025a357f05242fdad6a81e8a6b520098aa65a600 \
            --volume=out,kind=host,source="$PWD"/"$t" \
            --mount=volume=out,target=/"$t" \
            --set-env=AWS_ACCESS_KEY_ID="$AWS_ACCESS_KEY_ID" \
            --set-env=AWS_SECRET_ACCESS_KEY="$AWS_SECRET_ACCESS_KEY" \
            --exec=/usr/bin/aws -- s3 cp /"$t" "$MODULUS_S3_BUCKET" ; done
}

download() {
    local DRIVER_NAME=$1
    local DRIVER_VERSION=$2
    [ "$MODULUS_FORCE" = false ] && check_status "$DRIVER_NAME" "$DRIVER_VERSION" && exit 0

    mkdir -p "$MODULUS_DIR"/archive/"$DRIVER_NAME"/"$DRIVER_VERSION"
    pushd "$MODULUS_DIR"/archive/"$DRIVER_NAME"/"$DRIVER_VERSION" > /dev/null
    local t="$MODULUS_COREOS_RELEASE_VERSION"-"$MODULUS_GROUP"-"$DRIVER_NAME"-"$DRIVER_VERSION".tar.gz
    . /home/core/awsenv
    rkt run \
        --net=host \
        --dns=host \
        --trust-keys-from-https quay.io/coreos/awscli:025a357f05242fdad6a81e8a6b520098aa65a600 \
        --volume=out,kind=host,source="$PWD" \
        --mount=volume=out,target=/out \
        --set-env=AWS_ACCESS_KEY_ID="$AWS_ACCESS_KEY_ID" \
        --set-env=AWS_SECRET_ACCESS_KEY="$AWS_SECRET_ACCESS_KEY" \
        --exec=/usr/bin/aws -- s3 cp "$MODULUS_S3_BUCKET""$t" /out/"$t"
    tar -xvf "$t"
}

usage() {
    printf "%s is a tool for automatically compiling kernel modules.\n\n" "$(basename "$0")"
    printf "Usage:\n\n \t %s [options] command [arguments]\n\n" "$(basename "$0")"
    printf " The options are:\n\n"
    printf "\t -b BOARD         \tContainer Linux release board, e.g. amd64-usr\n"
    printf "\t -c               \tcheck for Container Linux release version using update engine\n"
    printf "\t -d               \tdirectory in which to archive all assets, e.g. /opt/modulus\n"
    printf "\t -D               \trun all containers with Docker\n"
    printf "\t -f               \tforce install even if modules are up to date\n"
    printf "\t -g GROUP         \tContainer Linux release group, i.e. alpha, beta, or stable\n"
    printf "\t -r RELEASE       \tContainer Linux release version, e.g. 1353.4.0\n"
    printf "\t -u               \tupload the driver to S3 after compiling\n"
    printf "\n"
    printf "The commands are:\n\n"
    printf "\t compile <module> <version> \tbuild the <module> kernel module\n"
    printf "\t download <module> <version>\tdownload the compiled kernel module and assets for <module> from S3 to %s/archive/<module>\n" "$MODULUS_DIR"
    printf "\t install <module> <version> \tinstall the <module> kernel module in /opt/<module> and install all libraries\n"
    printf "\t status <module> <version>  \tcheck if an up-to-date version of <module> is installed\n"
    printf "\t upload <module> <version>  \tupload the compiled kernel module and assets for <module> to s3\n"
    printf "\n"
}

case $1 in
    compile)
        compile "$2" "$3";;
    download)
        download "$2" "$3";;
    install)
        install "$2" "$3";;
    status)
        check_status "$2" "$3" && exit 0 || exit 1;;
    upload)
        upload "$2" "$3";;
    *)
        usage;;
esac
